# Flutter Todo List ObjectBox

This is a guide to create simple Todo App using ObjectBox.

## 1. Directory Structure

After we create new flutter project, we will form our directories by grouping the files into data, presentation, and state layers. Data layer includes all files regarding the manipulation of data inside the apps. Presentation layer includes all files regarding user interface, widgets, and app theme. Lastly the state folder handles all state across application. In this case, we use riverpod as state management solution. Below is the folder structure inside ```lib``` folder

```bash
lib
├── data
│   ├── models
│   │   └── task.dart
│   ├── objectbox
│   │   └── objectbox.dart
│   └── repositories
│       └── task_repository.dart
├── presentation
│   ├── screens
│   │   └── todo_list_screen.dart
│   ├── theme
│   │   └── app_theme.dart
│   └── widgets
│       ├── add_task_bottom_sheet.dart
│       └── edit_task_bottom_sheet.dart
├── state
│   └── providers
│       └── task_provider.dart
├── main.dart
├── objectbox.g.dart
└── objectbox-model.json
```

The last two files are generated by objectbox when running build_runner later on

## 2. Package Dependencies

All dependencies are already included in pubspec.yaml file. If you want to upgrade the dependencies to the latest version, just run ```flutter pub upgrade```. Our flutter dependencies will be like this:

```yaml
dependencies:
  flutter:
    sdk: flutter

  cupertino_icons: ^1.0.8
  google_fonts: ^6.2.1
  flex_color_scheme: ^8.2.0
  font_awesome_flutter: ^10.8.0
  intl: ^0.20.2
  flutter_riverpod: ^2.6.1
  riverpod_annotation: ^2.6.1
  objectbox: ^4.1.0
  objectbox_flutter_libs: ^4.1.0
  equatable: ^2.0.7

dev_dependencies:
  flutter_test:
    sdk: flutter

  flutter_lints: ^5.0.0
  build_runner: ^2.4.15
  objectbox_generator: ^4.1.0
  riverpod_generator: ^2.6.3
  riverpod_lint: ^2.6.3
  custom_lint: ^0.7.0
``` 
We will use objectbox_generator and build_runner to generate code for ObjectBox to run properly

## 3. Create Models for Task

We need to create model for task first. This model will be a blueprint for generated ObjectBox code. We can do this by using ```@Entity``` annotation to create an entity for our ObjectBox. All of our model files will be saved under ```lib/data/models``` directory. In this case we just need to create simple Task model that consist of title and description for the sake of simplicity. 

After we define our model, to generate necessary ObjectBox code then we need to run: 
```
dart run build_runner build
``` 
This command will generate two files in ```lib``` folder, ```objectbox-mode.json``` and ```objectbox.g.dart```. According to ObjectBox documentation, JSON file keeps track of unique IDs assigned to our entities and properties so that if we want to changes some entities or properties it can be done smoothly. Therefore, keeps this file and if you're using VCS(Version Control System), commit the changes into it.

## 4. Create an ObjectBox Store

According to documentation, [Store](https://pub.dev/documentation/objectbox/latest/objectbox/Store-class.html) is the entry point or direct interface to manage ObjectBox database and its Boxes. Usually in practice we want to only have a single Store (single database) and keep it open while our app is running without closing it explicitly. For this case we will create a new file named ```objectbox.dart``` inside ```lib/data/objectbox```. This file handles the creation ObjectBox Store.

```dart
late ObjectBox objectBox;

class ObjectBox {
  /// The Store of this app.
  late final Store store;

  ObjectBox._create(this.store) {
    // Add any additional setup code, e.g. build queries.
  }

  /// Create an instance of ObjectBox to use throughout the app.
  static Future<ObjectBox> create() async {
    final docsDir = await getApplicationDocumentsDirectory();
    // Future<Store> openStore() {...} is defined in the generated objectbox.g.dart
    final store = await openStore(directory: p.join(docsDir.path, "todo-objectbox"));
    return ObjectBox._create(store);
  }
}
```  

We will create ObjectBox instance that will be initialised later when we're running the app. Then under the ```create()``` method, we defined where to put our Store in device. Usually in mobile device, the data will be stored inside the app's document directory. We can also specify the ```directory``` parameter inside ```openStore()``` function to change the default directory location. Finally, the ObjectBox configuration for our app is completed. The next step is creating a repository to handle database operations.

## 5. Create Repository

We need to create a repository so that we can interact or do operations within our ObjectBox database. In this case we will create a Task entity repository named ```task_repository.dart``` inside ```lib/data/repositories``` directory. The code of the file is provided like this:

```dart
class TaskRepository {
  final Box<Task> _taskBox;

  TaskRepository(this._taskBox);

  Future<int> addTask(Task task) async {
    return _taskBox.put(task);
  }

  Future<void> updateTask(Task task) async {
    _taskBox.put(task);
  }

  Future<void> deleteTask(int id) async {
    _taskBox.remove(id);
  }

  Stream<List<Task>> watchAllTasks() {
    return _taskBox
        .query()
        .watch(triggerImmediately: true)
        .map((query) => query.find());
  }

  Future<List<Task>> getAllTasks() async {
    return _taskBox.query().build().find();
  }

  Future<Task?> getTaskById(int id) async {
    return _taskBox.get(id);
  }
}
```

With this code, we can do CRUD operations and also a provide a Stream that automatically updated when we create/update/delete task. 

## 6. Managing App State using Riverpod

After create the repository. We need a way for our UI to use the data and display it to the user. This is where riverpod plays a role. [Riverpod](riverpod.dev) is a state management library to manage app state so that it can be available to all of widget without passing the state across child widget. There are many types of state management solution provided by riverpod, we will use some of them to manage the data and provide it across the app so the UI/widget can consume/use it. 

We will create ```task_provider.dart``` inside ```lib/state/provider```. This file includes all the providers needed for the task model to interact with our UI later on.
#### taskRepositoryProvider

We will create a provider for Task Repository to be accessed by app. It creates an instance of objectbox store for task and exposes TaskRepository to be used inside the app. We use provider because it is read-only state and we won't change it when the app is running.

```dart
final taskRepositoryProvider = Provider<TaskRepository>((ref) {
  return TaskRepository(objectBox.store.box<Task>());
});
```

#### taskListProvider

After then, we need to create a stream of all tasks that watch changes from the database and updates the UI automatically to reflect the changes. We will use method ```watchAllTask()``` from ```TaskRepository``` to monitor the changes made inside database. ```ref.watch(taskRepositoryProvider)``` allows us to listen and re-create a state when there is a change in ```TaskRepository``` provider.

```dart
final taskListProvider = StreamProvider<List<Task>>((ref) {
  final taskRepository = ref.watch(taskRepositoryProvider);
  return taskRepository.watchAllTasks();
});
```

#### taskNotifier

After that, how about if we want to do CRUD operation from our UI? For example in the UI, user wants to add, edit, or delete task. We define ```TaskNotifier``` class that extends ```StateNotifier<List<Task>>```. ```StateNotifier``` is a riverpod class used to manage a mutable state. In this case it manages ```List<Task>``` and providing methods for our UI to interact with ObjectBox database. We will implement standard CRUD and ```toggleTaskCompletion``` methods that cover our needed operation for UI interactions. 

```dart
class TaskNotifier extends StateNotifier<List<Task>> {
  final TaskRepository _taskRepository;

  TaskNotifier(this._taskRepository) : super([]);

  Future<void> addTask(String title, String description) async {
    final newTask = Task(title: title, description: description);
    await _taskRepository.addTask(newTask);
  }

  Future<void> updateTask(Task task) async {
    await _taskRepository.updateTask(task);
  }

  Future<void> deleteTask(int id) async {
    await _taskRepository.deleteTask(id);
  }

  Future<void> toggleTaskCompletion(Task task) async {
    final updatedTask = Task(
      id: task.id,
      title: task.title,
      description: task.description,
      isCompleted: !task.isCompleted,
    );
    await _taskRepository.updateTask(updatedTask);
  }
}
```

#### taskProvider

Finally, we need to expose our ```taskNotifier``` class so that it can be used by the UI/widgets in our flutter app. We define a ```StateNotifierProvider``` named ```taskProvider```. This ```taskProvider``` allows our UI to interact with ```taskNotifier``` instance. Then we can use it to manipulates the Todo List and display it to user. 

```dart
final taskProvider = StateNotifierProvider<TaskNotifier, List<Task>>((ref) {
  final taskRepository = ref.watch(taskRepositoryProvider);
  return TaskNotifier(taskRepository);
});
```

## 7. Initialised Riverpod and ObjectBox

To enable Riverpod in our flutter application, we need to wrap our main app/root widget with ```ProviderScope()```. This is done in our code inside ```main.dart```

```dart
void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  objectBox = await ObjectBox.create();
  runApp(const ProviderScope(child: MyApp()));
}

class MyApp extends ConsumerWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return MaterialApp(
      title: 'Simple Todo List',
      theme: AppTheme.light,
      home: const TodoListScreen(),
    );
  }
}
```

We also need to change ```StatelessWidget``` to  ```ConsumerWidget``` and ```StatefulWidget``` to ```ConsumerStatefulWidget``` so that the widget tree can listen to changes on provider and the UI can automatically be updated when needed.

Next, we need to initialised ObjectBox database for our applications. This is done by this line of code:

```dart
  WidgetsFlutterBinding.ensureInitialized();
  objectBox = await ObjectBox.create();
```

We need to ensure objectBox is initialised before flutter calls ```RunApp()```. Thus we use ```WidgetsFlutterBinding.ensureInitialized()```. Then we create and instance of objectBox database to be used in our app.

## 8. Creating UI

We will create simple interface for our ToDo app. The presentation directory consists of ```theme``` to defined theme for our app to use. In this case we are using ```flex_color_scheme``` package to generate the theme. Then the ```screens``` directory that contains our entire screen widgets and ```widget``` directory for reusable widgets. For this app, we just need one screen to display list of tasks using ```card``` and ```ListTile``` widget with ```ListView.Builder```. Then, to add and edit the task we use ```modalBottomSheet``` to fill the title and description of the task. For the details of implementation, you can see the files under presentation directory. We will only give explanation for how to display the data from provider to the screen.

We need to monitor the state of our task list, so that if there is a change to the state, we can handle what to display on our screen. For this we initialise variable:

```dart
final taskListAsyncValue = ref.watch(taskListProvider);
```
This piece of code use ```ref.watch()``` to get the value of provider every time there is a change. This variable will be used to define our body in ```Scaffold```.

```dart
    body: taskListAsyncValue.when(
        data: (tasks) => tasks.isEmpty
            ? const Center(child: Text('No tasks yet. Add some!'))
            : ListView.builder(
          itemCount: tasks.length,
          itemBuilder: (context, index) {
            final task = tasks[index];
            return Card(
              margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
              child: InkWell( // Make the ListTile tappable
                onTap: () {
                  _showEditTaskBottomSheet(context, ref, task);
                },
                child: ListTile(
                  leading: Checkbox(
                    value: task.isCompleted,
                    onChanged: (value) {
                      if (value != null) {
                        ref.read(taskProvider.notifier).toggleTaskCompletion(task);
                      }
                    },
                  ),
                  title: Text(
                    task.title,
                    style: TextStyle(
                      decoration: task.isCompleted
                          ? TextDecoration.lineThrough
                          : null,
                    ),
                  ),
                  subtitle: task.description.isNotEmpty
                      ? Text(
                    task.description,
                    style: TextStyle(
                      decoration: task.isCompleted
                          ? TextDecoration.lineThrough
                          : null,
                    ),
                  )
                      : null,
                  trailing: IconButton(
                    icon: const Icon(Icons.delete_outline),
                    onPressed: () =>
                        _showDeleteConfirmationDialog(context, ref, task.id, task.title),
                  ),
                ),
              ),
            );
          },
        ),
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (error, stackTrace) => Center(child: Text('Error: $error')),
      ),
```

We can see, if there is data, then we check if there is task inside the list. If there is not, then it will print ```No tasks yet. Add some!```. If there is task, then we use ```ListView.Builder``` widget to create list of task. The task list data already provided by ```taskListAsyncValue```, we just need to consume it in ```itemBuilder```. If we want to change the checkbox value to indicate a task is completed, we just need to use ```ref.read(taskProvider.notifier).toggleTaskCompletion(task)```. If we want to edit the task, we use function ```_showEditTaskBottomSheet``` to show the ```edit_task_bottom_sheet.dart``` into ```showModalBottomSheet``` widget

```dart
void _showEditTaskBottomSheet(BuildContext context, WidgetRef ref, Task task) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      builder: (BuildContext context) => EditTaskBottomSheet(task: task),
    );
  }
```

We also create a Future function to handle deletion of task because we need to show dialog to confirm is user want to delete the task or not. We also need to call ```ref.read(taskProvider.notifier).deleteTask(taskId)``` from provider to delete the task. The full code is shown below:

```dart
Future<void> _showDeleteConfirmationDialog(
      BuildContext context,
      WidgetRef ref,
      int taskId,
      String taskTitle,
      ) async {
    return showDialog<void>(
      context: context,
      barrierDismissible: false,
      builder: (BuildContext context) {
        return AlertDialog(
          title: const Text('Confirm Delete'),
          content: SingleChildScrollView(
            child: ListBody(
              children: <Widget>[
                Text('Are you sure you want to delete the task "$taskTitle"?'),
              ],
            ),
          ),
          actions: <Widget>[
            TextButton(
              child: const Text('Cancel'),
              onPressed: () {
                Navigator.of(context).pop();
              },
            ),
            TextButton(
              style: TextButton.styleFrom(foregroundColor: Colors.red),
              child: const Text('Delete'),
              onPressed: () {
                ref.read(taskProvider.notifier).deleteTask(taskId);
                Navigator.of(context).pop();
              },
            ),
          ],
        );
      },
    );
  }
  ```

  Voila!!! We already create a simple Todo List App using ObjectBox as local database